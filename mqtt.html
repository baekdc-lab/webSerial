<!doctype html><html lang="ko"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ESP32 센서 대시보드</title>
<style>
:root{
  --bg:#0b1020;--card:#131a2b;--txt:#e8eefc;--mut:#9fb2d7;--line:#22314f;
  --btn-bg:#1b2b4a;--btn-border:#2c3e63;
}
:root.light{
  --bg:#f5f7fa;--card:#ffffff;--txt:#0b1020;--mut:#5a6b8a;--line:#ccd4e0;
  --btn-bg:#e4e8ef;--btn-border:#b0bacb;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--txt);font:16px/1.5 system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,sans-serif;transition:background .3s,color .3s}
.wrap{max-width:900px;margin:20px auto;padding:0 12px}
.card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);transition:background .3s}
h1{margin:0 0 8px;font-size:26px;font-weight:800;display:flex;justify-content:space-between;align-items:center}
.mut{color:var(--mut);margin:0 0 12px}
.status{margin-top:8px;color:var(--mut);font-size:14px}
hr{border:0;border-top:1px solid var(--line);margin:14px 0;transition:border-color .3s}

/* Theme toggle */
.theme-toggle{cursor:pointer;font-size:22px;user-select:none;transition:transform .2s}
.theme-toggle:hover{transform:scale(1.15)}

/* KPI Tiles */
.grid{display:grid;grid-template-columns:repeat(5,minmax(0,1fr));gap:12px;margin-top:6px}
.tile{background:#0f1526;border-radius:12px;padding:12px;text-align:center;min-height:76px;transition:background .3s}
:root.light .tile{background:#eef1f7}
.v{font-size:22px;font-weight:800;margin-top:4px}

/* LED 버튼 */
.led{display:flex;align-items:center;gap:12px;margin-top:12px;flex-wrap:wrap}
.btn{border:0;color:#fff;padding:12px 14px;border-radius:12px;cursor:pointer;font-weight:800;min-width:98px;font-size:15px;transition:all .2s}
.btn.on{background:#2d6bff;} .btn.off{background:#32405e;} .btn.active{background:#00cc66;} .btn.dim{background:#1b2236;}
.btn.toggle{background:var(--btn-bg);border:1px solid var(--btn-border);color:var(--txt);min-width:120px}

/* 토글 버튼 한 줄 */
.toggle-row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 12px}

/* 숨김/펼침 애니메이션 */
.collapsible{max-height:0;overflow:hidden;transition:max-height .5s ease,padding .3s ease,opacity .3s ease;opacity:0}
.collapsible.open{max-height:2000px;padding-top:6px;opacity:1}

/* ===== 테이블 ===== */
.tablewrap{overflow:auto;background:#0f1526;border-radius:14px;padding:0 6px 6px 0;max-height:50vh;transition:background .3s}
:root.light .tablewrap{background:#eef1f7}
table{border-collapse:collapse;width:auto;min-width:100%;table-layout:auto}
thead th{position:sticky;top:0;z-index:2;background:#12203a;white-space:nowrap;transition:background .3s}
:root.light thead th{background:#d6deec}
th,td{padding:6px 8px;border-bottom:1px solid var(--line);text-align:right;font-size:13px;line-height:1.5;transition:border-color .3s}
th:first-child,td:first-child{text-align:center;padding-left:0;padding-right:4px}
th:nth-child(1){width:54px}
th:nth-child(2),th:nth-child(3),th:nth-child(4),th:nth-child(5){width:63px}
th:nth-child(6){width:72px}
th:nth-child(7){width:52px}

/* ===== Charts ===== */
.charts{margin-top:14px;display:grid;grid-template-columns:1fr;gap:12px}
.chart{background:#0f1526;border-radius:12px;padding:10px;transition:background .3s}
:root.light .chart{background:#eef1f7}
.chart h3{margin:0 0 8px;font-size:15px;color:var(--mut);font-weight:700}
.canvas-wrap{position:relative;width:100%;height:180px}
.canvas-wrap canvas{position:absolute;left:0;top:0;width:100%;height:100%}

#raw{white-space:pre-line;font-size:12px;color:var(--mut)}

@media (max-width:480px){
  h1{font-size:22px}
  .grid{gap:10px} .tile{padding:12px;min-height:70px} .v{font-size:20px}
  .btn{min-width:96px;font-size:15px;padding:12px}
  th,td{padding:8px 6px;font-size:14px}
  .tablewrap{max-height:52vh}
  .canvas-wrap{height:160px}
}
</style></head><body>
<div class="wrap"><div class="card">
  <h1>ESP32 센서 대시보드
    <span class="theme-toggle" id="themeToggle">🌙</span>
  </h1>
  <p class="mut">AHT25(온/습) + SCD42(온/습/CO₂) · LED제어</p>

  <div id="banner" class="status">—</div>
  <div class="grid">
    <div class="tile"><div>AHT25 온도</div><div id="aht_t" class="v">--.- °C</div></div>
    <div class="tile"><div>AHT25 습도</div><div id="aht_h" class="v">-- %</div></div>
    <div class="tile"><div>SCD42 온도</div><div id="scd_t" class="v">--.- °C</div></div>
    <div class="tile"><div>SCD42 습도</div><div id="scd_h" class="v">-- %</div></div>
    <div class="tile"><div>CO₂ 공기</div><div id="scd_c" class="v">---- ppm</div></div>
  </div>

  <div class="led">
    <button id="on"  class="btn on">LED ON</button>
    <button id="off" class="btn off">LED OFF</button>
    <div id="led" class="status">LED: -</div>
  </div>

  <hr>
  <div class="toggle-row">
    <button class="btn toggle" id="toggleTable">📋 테이블 보기</button>
    <button class="btn toggle" id="toggleGraph">📊 그래프 보기</button>
  </div>

  <!-- 기본 접힘 -->
  <div id="tableSection" class="collapsible">
    <div class="tablewrap">
      <table>
        <thead>
          <tr>
            <th>시간</th>
            <th>AHT&nbsp;°C</th>
            <th>AHT&nbsp;%</th>
            <th>SCD&nbsp;°C</th>
            <th>SCD&nbsp;%</th>
            <th>CO₂</th>
            <th>LED</th>
          </tr>
        </thead>
        <tbody id="logtbl"></tbody>
      </table>
    </div>
  </div>

  <div id="graphSection" class="collapsible">
    <div class="charts">
      <div class="chart"><h3>온도 (°C) — 최근 60분</h3><div class="canvas-wrap"><canvas id="chTemp"></canvas></div></div>
      <div class="chart"><h3>습도 (%) — 최근 60분</h3><div class="canvas-wrap"><canvas id="chHum"></canvas></div></div>
      <div class="chart"><h3>CO₂ (ppm) — 최근 60분</h3><div class="canvas-wrap"><canvas id="chCO2"></canvas></div></div>
    </div>
  </div>

  <hr>
  <div class="status" id="raw">—</div>
</div></div>

<script>
const $=s=>document.querySelector(s);
const fastMs=3000, maxRows=60;

/* ===== Theme toggle (instant chart redraw) ===== */
const themeToggle=$('#themeToggle');
function applyTheme(t){
  document.documentElement.classList.toggle('light', t==='light');
  themeToggle.textContent = (t==='light') ? '☀️' : '🌙';
  renderAllCharts();
}
applyTheme(localStorage.getItem('theme')||'dark');
themeToggle.onclick=()=>{const t=document.documentElement.classList.contains('light')?'dark':'light';applyTheme(t);localStorage.setItem('theme',t);};

/* ===== Toggle buttons ===== */
function setToggle(btn,sec,labelShow,labelHide){
  const sync=()=>btn.textContent=sec.classList.contains('open')?labelHide:labelShow;
  btn.addEventListener('click',()=>{sec.classList.toggle('open');sync();if(sec.id==='graphSection'&&sec.classList.contains('open'))renderAllCharts();});
  sync();
}
setToggle($('#toggleTable'),$('#tableSection'),'📋 테이블 보기','📋 테이블 숨기기');
setToggle($('#toggleGraph'),$('#graphSection'),'📊 그래프 보기','📊 그래프 숨기기');

/* ===== Resilient endpoints ===== */
const EP = {
  status : ['/api/status','/status','/readings','/get','/api/readings'],
  history60: ['/api/history?limit=60','/history?limit=60','/api/history','/history','/logs'],
  history1 : ['/api/history?limit=1','/history?limit=1','/api/history','/history'],
  line   : ['/api/line','/line','/log','/last'],
  ledOn  : ['/api/led?state=on','/led/on','/api/led/on','/set?led=1'],
  ledOff : ['/api/led?state=off','/led/off','/api/led/off','/set?led=0'],
};
async function fetchFirstJson(cands,opt={}){for(const u of cands){try{const r=await fetch(u,{...opt,cache:'no-store'});if(!r.ok)continue;return await r.json();}catch(e){}}throw new Error('모든 경로 실패');}
async function fetchFirstText(cands,opt={}){for(const u of cands){try{const r=await fetch(u,{...opt,cache:'no-store'});if(!r.ok)continue;return await r.text();}catch(e){}}return '';}
async function hitFirst(cands){for(const u of cands){try{const r=await fetch(u,{cache:'no-store'});if(r.ok)return true;}catch(e){}}return false;}

/* ===== Formatters ===== */
const fmtT=v=>v==null?'--.-':Number(v).toFixed(1);
const fmtP=v=>v==null?'--':Math.round(Number(v));
const fmtC=v=>v==null?'----':Number(v);

/* ===== LED buttons state ===== */
function syncButtons(led){const on=$('#on'),off=$('#off');on.classList.remove('active','dim');off.classList.remove('active','dim');if(led){on.classList.add('active');off.classList.add('dim');}else{off.classList.add('active');on.classList.add('dim');}}

/* ===== Data buffer ===== */
let histBuf=[];

/* ===== Status poll ===== */
async function refreshFast(){
  try{
    const s=await fetchFirstJson(EP.status);
    const aht_t=s.aht_t??s.aht_temp??s.temp??s.aht?.t;
    const aht_h=s.aht_h??s.aht_hum ??s.hum ??s.aht?.h;
    const scd_t=s.scd_t??s.scd_temp??s.st   ??s.scd?.t;
    const scd_h=s.scd_h??s.scd_hum ??s.sh   ??s.scd?.h;
    const co2  =s.co2  ??s.scd_co2 ??s.ppm  ??s.scd?.co2;
    const led  =(s.led=='1'||s.led===1||s.led==='on'||s.led===true);

    $('#aht_t').textContent=aht_t!=null?Number(aht_t).toFixed(1)+' °C':'--.- °C';
    $('#aht_h').textContent=aht_h!=null?Math.round(Number(aht_h))+' %':'-- %';
    $('#scd_t').textContent=scd_t!=null?Number(scd_t).toFixed(1)+' °C':'--.- °C';
    $('#scd_h').textContent=scd_h!=null?Math.round(Number(scd_h))+' %':'-- %';
    $('#scd_c').textContent=co2!=null?(co2+' ppm'):'---- ppm';
    $('#led').textContent='LED: '+(led?'ON':'OFF');
    syncButtons(led);

    const line=await fetchFirstText(EP.line);
    $('#raw').textContent=line||'';
    $('#banner').textContent=`AHT25/SCD42 연결 OK${s.rssi?` · RSSI: ${s.rssi}[dBm]`:''}`;
  }catch(e){$('#banner').textContent='통신 오류: '+e.message;}
}

/* ===== History (table + charts) ===== */
function normalizeRec(o){
  return {
    aht_t:Number(o.aht_t ?? o.aht_temp ?? o.temp ?? o.at) || NaN,
    aht_h:Number(o.aht_h ?? o.aht_hum  ?? o.hum  ?? o.ah) || NaN,
    scd_t:Number(o.scd_t ?? o.scd_temp ?? o.st) || NaN,
    scd_h:Number(o.scd_h ?? o.scd_hum  ?? o.sh) || NaN,
    co2  :Number(o.co2   ?? o.scd_co2  ?? o.ppm)|| NaN,
    led  :(o.led=='1'||o.led===1||o.led==='on')?1:0
  };
}
function addRowTop(obj, ts){
  const tbody=$('#logtbl');
  const d=ts?new Date(ts):new Date();
  const hh=String(d.getHours()).padStart(2,'0');
  const mm=String(d.getMinutes()).padStart(2,'0');
  const tr=document.createElement('tr');
  tr.innerHTML=`
    <td>${hh}:${mm}</td>
    <td>${fmtT(obj.aht_t ?? obj.aht_temp ?? obj.temp)}</td>
    <td>${fmtP(obj.aht_h ?? obj.aht_hum  ?? obj.hum)}</td>
    <td>${fmtT(obj.scd_t ?? obj.scd_temp)}</td>
    <td>${fmtP(obj.scd_h ?? obj.scd_hum)}</td>
    <td>${fmtC(obj.co2   ?? obj.scd_co2)}</td>
    <td>${(obj.led=='1'||obj.led===1||obj.led==='on')?'ON':'OFF'}</td>`;
  if(tbody.firstChild) tbody.insertBefore(tr, tbody.firstChild); else tbody.appendChild(tr);
  while(tbody.rows.length>maxRows) tbody.deleteRow(tbody.rows.length-1);
}
async function loadHistory60(){
  try{
    const list=await fetchFirstJson(EP.history60);
    const tbody=$('#logtbl'); tbody.innerHTML='';
    histBuf=[];
    const now=Date.now();
    for(let i=list.length-1;i>=0;i--){
      const it=list[i];
      const ts=it.timestamp?new Date(it.timestamp):new Date(now-(it.age||0)*60000);
      addRowTop(it,ts);
      histBuf.push(normalizeRec(it));
    }
    while(histBuf.length>maxRows) histBuf.shift();
  }catch(e){}
}
async function refreshLogOne(){
  try{
    const one=await fetchFirstJson(EP.history1);
    const item=Array.isArray(one)?one[0]:one; if(!item) return;
    const now=Date.now();
    const ts=item.timestamp?new Date(item.timestamp):new Date(now-(item.age||0)*60000);
    addRowTop(item,ts);
    histBuf.push(normalizeRec(item)); if(histBuf.length>maxRows) histBuf.shift();
    renderAllCharts();
  }catch(e){}
}

/* ===== Mini chart engine ===== */
const dpr=()=>window.devicePixelRatio||1;
function prepCanvas(canvas){
  const rect=canvas.getBoundingClientRect(); const w=Math.max(1,rect.width), h=Math.max(1,rect.height);
  canvas.width=Math.floor(w*dpr()); canvas.height=Math.floor(h*dpr());
  const ctx=canvas.getContext('2d'); ctx.setTransform(dpr(),0,0,dpr(),0,0); return ctx;
}
function drawChart(canvas, series){
  const ctx=prepCanvas(canvas);
  const W=Math.max(1,canvas.getBoundingClientRect().width), H=Math.max(1,canvas.getBoundingClientRect().height);
  const padL=34,padR=10,padT=10,padB=24,plotW=Math.max(1,W-padL-padR),plotH=Math.max(1,H-padT-padB);

  const light=document.documentElement.classList.contains('light');
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle=light?'#eef1f7':'#0f1526'; ctx.fillRect(0,0,W,H);

  ctx.strokeStyle=light?'#ccd4e0':'#22314f'; ctx.beginPath();
  for(let g=0;g<=4;g++){const y=padT+plotH*g/4;ctx.moveTo(padL,y);ctx.lineTo(padL+plotW,y);}
  for(let m=0;m<=60;m+=10){const x=padL+plotW*(m/60);ctx.moveTo(x,padT);ctx.lineTo(x,padT+plotH);}
  ctx.stroke();

  ctx.fillStyle=light?'#5a6b8a':'#9fb2d7'; ctx.font='12px system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,sans-serif';
  ctx.textAlign='center'; ctx.textBaseline='top';
  for(let m=0;m<=60;m+=10){const x=padL+plotW*(m/60);ctx.fillText((60-m)==0?'지금':`-${60-m}m`,x,padT+plotH+6);}

  const vals=[]; for(const s of series){for(const v of s.data){if(Number.isFinite(v)) vals.push(v);}}
  let vmin=Math.min(...(vals.length?vals:[0])), vmax=Math.max(...(vals.length?vals:[1])); if(vmax===vmin){vmax=vmin+1;}
  const pad=(vmax-vmin)*0.1; vmin-=pad; vmax+=pad;

  ctx.textAlign='right'; ctx.textBaseline='middle';
  for(let g=0;g<=4;g++){const y=padT+plotH*g/4, val=vmax-(vmax-vmin)*g/4; ctx.fillText(val.toFixed((vmax-vmin)<10?1:0), padL-6, y);}

  function xAt(i){return padL+plotW*(i/59);} function yAt(v){return padT+((vmax-v)/ (vmax-vmin))*plotH;}
  const colors=['#7aa0ff','#ff9a7a','#7affb0','#ffd67a','#c67aff']; let ci=0;
  for(const s of series){
    ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle=s.color||colors[ci++%colors.length];
    let moved=false; const N=s.data.length;
    for(let i=0;i<60;i++){
      const idx=i-(60-N); const v=(idx>=0&&idx<N)?s.data[idx]:NaN; const x=xAt(i);
      if(Number.isFinite(v)){const y=yAt(v); if(!moved){ctx.moveTo(x,y); moved=true;} else ctx.lineTo(x,y);} else moved=false;
    }
    ctx.stroke();
  }
}
function renderAllCharts(){
  if(!$('#graphSection').classList.contains('open')) return;
  const aht_t=histBuf.map(r=>r.aht_t), scd_t=histBuf.map(r=>r.scd_t);
  const aht_h=histBuf.map(r=>r.aht_h), scd_h=histBuf.map(r=>r.scd_h);
  const co2  =histBuf.map(r=>r.co2);
  drawChart($('#chTemp'),[{data:aht_t},{data:scd_t}]);
  drawChart($('#chHum'), [{data:aht_h},{data:scd_h}]);
  drawChart($('#chCO2'), [{data:co2}]);
}

/* ===== Boot ===== */
(async()=>{
  await loadHistory60();
  await refreshFast();
  setInterval(refreshFast, fastMs);
  setInterval(refreshLogOne, 60000);
  $('#on').onclick  = async()=>{await hitFirst(EP.ledOn);  refreshFast();};
  $('#off').onclick = async()=>{await hitFirst(EP.ledOff); refreshFast();};
})();
</script>

<!-- ===== MQTT/WSS 오버레이: /api/* 를 MQTT 데이터로 대체 (디자인/레이아웃 불변) ===== -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script>
(function(){
  // 브로커(스케치와 동일)
  const HOST="6c56aefe0ddb4d57977c735f5070abe8.s1.eu.hivemq.cloud";
  const PORT=8884, PATH="/mqtt", USER="mqtt_ESP32", PASS="gomqtt_ESP32";

  // MQTT 상태 버퍼 → 원본 함수들이 fetch로 가져가게 위조
  const statusBuf = { aht_t:null,aht_h:null,scd_t:null,scd_h:null,co2:null,rssi:null,led:false };
  const historyBuf = []; // 최근 60개
  const MAX=60;
  let chip=null, client=null;

  // fetch/XHR 인터셉트: 원본 JS는 그대로, 네트워크만 우리가 답변
  const realFetch = window.fetch.bind(window);
  window.fetch = (input, init={})=>{
    const url=(typeof input==='string')?input:(input&&input.url)||'';
    // /api/status
    if(url.includes('/api/status') || url.endsWith('/status') || url.endsWith('/readings') || url.endsWith('/get')){
      return Promise.resolve(new Response(JSON.stringify(statusBuf),{status:200,headers:{'Content-Type':'application/json'}}));
    }
    // /api/history
    if(url.includes('/api/history')){
      const params=new URL(url,location.origin).searchParams;
      const lim=parseInt(params.get('limit')||'60',10);
      const arr=historyBuf.slice(-lim).map(x=>({ ...x }));
      return Promise.resolve(new Response(JSON.stringify(arr),{status:200,headers:{'Content-Type':'application/json'}}));
    }
    // /api/line → 임의 텍스트
    if(url.includes('/api/line') || url.endsWith('/line') || url.endsWith('/log') || url.endsWith('/last')){
      const s=statusBuf;
      const line = `AHT:${s.aht_t??'-'}/${s.aht_h??'-'} · SCD:${s.scd_t??'-'}/${s.scd_h??'-'} · CO2:${s.co2??'-'} · RSSI:${s.rssi??'-'} dBm`;
      return Promise.resolve(new Response(line,{status:200,headers:{'Content-Type':'text/plain'}}));
    }
    // /api/led
    if(url.includes('/api/led')){
      const u=new URL(url,location.origin);
      const state=(u.searchParams.get('state')||'').toLowerCase()==='on'?'on':'off';
      if(client && client.connected && chip){
        client.publish(`esp32/${chip}/cmd/led`, state, {qos:1});
        statusBuf.led=(state==='on'); // 낙관 반영
      }
      return Promise.resolve(new Response('OK',{status:200,headers:{'Content-Type':'text/plain'}}));
    }
    return realFetch(input, init);
  };

  // MQTT 연결
  const url=`wss://${HOST}:${PORT}${PATH}`;
  const cid='web_'+Math.random().toString(16).slice(2);
  client=mqtt.connect(url,{username:USER,password:PASS,clientId:cid,clean:true,keepalive:30,connectTimeout:10000,protocolVersion:4});

  client.on('connect', ()=>{
    client.subscribe('esp32/+/status',{qos:1});
    client.subscribe('esp32/+/state/led',{qos:1});
  });

  client.on('message', (topic, payload)=>{
    try{
      const seg=topic.split('/'); if(seg[0]!=='esp32'||seg.length<3) return;
      const c=seg[1]; if(!chip) chip=c; if(c!==chip) return;

      if(topic.endsWith('/status')){
        const s=JSON.parse(payload.toString());
        // 상태 버퍼 업데이트 (원본 포맷 호환 키)
        statusBuf.aht_t = s.aht_t ?? s.aht ?? s.at ?? null;
        statusBuf.aht_h = s.aht_h ?? s.ah  ?? null;
        statusBuf.scd_t = s.scd_t ?? s.st  ?? null;
        statusBuf.scd_h = s.scd_h ?? s.sh  ?? null;
        statusBuf.co2   = (s.co2>0)? s.co2 : null;
        statusBuf.rssi  = s.rssi ?? null;
        if(typeof s.led!=='undefined') statusBuf.led = (s.led===true || s.led==='on' || s.led===1);

        // 히스토리 버퍼
        historyBuf.push({ aht_t:statusBuf.aht_t, aht_h:statusBuf.aht_h, scd_t:statusBuf.scd_t, scd_h:statusBuf.scd_h, co2:statusBuf.co2, led:statusBuf.led, timestamp:new Date().toISOString() });
        while(historyBuf.length>MAX) historyBuf.shift();
      }else if(topic.endsWith('/state/led')){
        const on=(payload.toString().trim().toLowerCase()==='on');
        statusBuf.led=on;
      }
    }catch(e){/* ignore */}
  });
})();
</script>
</body></html>
